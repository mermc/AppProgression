import { Component, OnInit, ElementRef, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { Firestore, collection, collectionData, doc, getDoc } from '@angular/fire/firestore';
import { Chart, registerables } from 'chart.js';
import html2canvas from 'html2canvas';
import { map } from 'rxjs/operators';
import { MatDialogModule, MatDialog } from '@angular/material/dialog';
import { NoRegistrosDialog } from './no-registro-dialog/no-registro-dialog';


Chart.register(...registerables);

@Component({
  selector: 'app-registro-stats',
  standalone: true,
  imports: [CommonModule, MatDialogModule],
  templateUrl: './registro-stats.html',
  styleUrls: ['./registro-stats.scss']
})
export class RegistroStats implements OnInit {
  @ViewChild('chartCanvas') chartCanvas!: ElementRef<HTMLCanvasElement>;
  @ViewChild('exportContainer') exportContainer!: ElementRef<HTMLDivElement>;

  tipo!: 'personas' | 'grupos';
  id!: string;
  itemId!: string;
  itemNombre: string = '';
  chart: any;
  allItems: any[] = [];   // todos los items del usuario/grupo
  selectedItemIds: string[] = []; // ids seleccionados (incluye item principal)
  datesCacheByItem: Record<string, Date[]> = {}; // cache por item
  itemsInfo: Record<string, any> = {}; // color, descripcion, etc.

  // Configuration: how many months to show in the monthly comparison
  monthsToShow = 6; // default
  monthsOptions = [3, 6, 12];

  // UI helpers
  lastPercentChangeText: string = '';
  autogeneratedCaption: string = '';

  // Cache raw dates so switching months is instant without extra network calls
  private datesCache: Date[] = [];

  constructor(
    private route: ActivatedRoute,
    private firestore: Firestore,
    private router: Router,
    private dialog: MatDialog
  ) {}

  async ngOnInit() {
    this.tipo = this.route.snapshot.paramMap.get('tipo') as 'personas' | 'grupos';
    this.id = this.route.snapshot.paramMap.get('id')!;
    this.itemId = this.route.snapshot.paramMap.get('itemId')!;

    // 1. Obtener nombre del ítem
    const itemRef = doc(this.firestore, `${this.tipo}/${this.id}/items/${this.itemId}`);
    const itemSnap = await getDoc(itemRef);
    if (itemSnap.exists()) {
      this.itemNombre = itemSnap.data()['descripcion'] || '(Sin nombre)';
    } else {
      this.itemNombre = '(Ítem no encontrado)';
    }

    // 1.b Cargar todos los items del usuario/grupo para selección múltiple
    const itemsRef = collection(this.firestore, `${this.tipo}/${this.id}/items`);
    collectionData(itemsRef, { idField: 'id' }).subscribe((items: any[]) => {
      this.allItems = items.filter(i => i.fecha); // aseguramos consistencia

      // Guardar info de cada item
      for (const it of this.allItems) {
        this.itemsInfo[it.id] = {
          descripcion: it.descripcion,
          color: it.color || '#3f51b5'  // color por defecto
        };
      }

      // Seleccionar por defecto solo el item principal
      this.selectedItemIds = [this.itemId];

      // Una vez cargados, podemos cargar registros
      this.cargarRegistros();
    });
  }

  cargarRegistros() {
    // load registros for currently selected items
    for (const itemId of this.selectedItemIds) {
      const registrosRef = collection(
        this.firestore,
        `${this.tipo}/${this.id}/items/${itemId}/registros`
      );

      collectionData(registrosRef, { idField: 'id' })
        .pipe(
          map((registros: any[]) =>
            registros
              .filter(r => r.fecha)
              .sort(
                (a, b) =>
                  new Date(a.fecha.seconds ? a.fecha.seconds * 1000 : a.fecha).getTime() -
                  new Date(b.fecha.seconds ? b.fecha.seconds * 1000 : b.fecha).getTime()
              )
          )
        )
        .subscribe((registrosOrdenados) => {

          // Convertir a Date
          const fechas = registrosOrdenados.map(r =>
            new Date(r.fecha.seconds ? r.fecha.seconds * 1000 : r.fecha)
          );

          // Guardar cache por ítem
          this.datesCacheByItem[itemId] = fechas;

          // Keep single-item cache in sync when it's the primary item
          if (itemId === this.itemId) {
            this.datesCache = fechas;
          }

          // Redibujar
          this.refreshMultiItemView();
        });
    }
  }

  refreshMultiItemView() {
    // If only one item is selected, draw the single-item chart so caption/percent are consistent
    if (this.selectedItemIds.length === 1) {
      const onlyId = this.selectedItemIds[0];
      const fechas = this.datesCacheByItem[onlyId] || [];
      this.datesCache = fechas;
      const { labels, counts, percentChange, trend } = this.aggregateByMonth(fechas, this.monthsToShow);
      this.lastPercentChangeText = percentChange;
      this.autogeneratedCaption = this.buildAutogeneratedCaption(counts, percentChange);
      const itemColor = this.getColorForItem(onlyId);
      this.dibujarGraficoMensual(labels, counts, trend, itemColor);
      return;
    }

    // Multi-item: build datasets
    const datasets: any[] = [];
    let labels: string[] = [];

    for (const itemId of this.selectedItemIds) {
      const fechas = this.datesCacheByItem[itemId] || [];
      const { labels: lbls, counts, trend } = this.aggregateByMonth(fechas, this.monthsToShow);
      labels = lbls; // same months for all items

      const info = this.itemsInfo[itemId] || { descripcion: itemId, color: '#888' };

      datasets.push({
        type: 'bar',
        label: info.descripcion,
        data: counts,
        backgroundColor: info.color,
        borderRadius: 6
      });

      datasets.push({
        type: 'line',
        label: `${info.descripcion} — Tendencia`,
        data: trend,
        borderColor: this.ensureAlpha(info.color, 0.6),
        borderWidth: 2,
        fill: false,
        tension: 0.3,
        pointRadius: 0,
        borderDash: [5, 4]
      });
    }

    this.dibujarGraficoMulti(labels, datasets);
  }

  dibujarGraficoMulti(labels: string[], datasets: any[]) {
    if (this.chart) this.chart.destroy();

    const ctx = this.chartCanvas.nativeElement.getContext('2d')!;
    this.chart = new Chart(ctx, {
      type: 'bar',
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, position: 'top' },
          title: { display: true, text: `Progresión combinada — Últimos ${labels.length} meses` }
        },
        scales: {
          y: { beginAtZero: true, title: { display: true, text: 'Cantidad' } },
          x: { title: { display: true, text: 'Mes' } }
        }
      }
    });
  }

  toggleItem(item: any) {
    // If removing the item
    if (this.selectedItemIds.includes(item.id)) {
      this.selectedItemIds = this.selectedItemIds.filter(id => id !== item.id);
      this.refreshMultiItemView();
      return;
    }

    // If adding an item -> check if it has registros before accepting
    const registrosRef = collection(
      this.firestore,
      `${this.tipo}/${this.id}/items/${item.id}/registros`
    );

    collectionData(registrosRef, { idField: 'id' })
      .pipe(map((registros: any[]) => registros.filter(r => r.fecha)))
      .subscribe(registros => {
        if (registros.length === 0) {
          this.dialog.open(NoRegistrosDialog, { width: '400px' });
          return;
        }

        // allow selection
        this.selectedItemIds.push(item.id);

        const fechas = registros.map(r =>
          new Date(r.fecha.seconds ? r.fecha.seconds * 1000 : r.fecha)
        );
        this.datesCacheByItem[item.id] = fechas;
        this.refreshMultiItemView();
      });
  }

  // Select or deselect all available items (convenience)
  toggleSelectAll() {
    if (this.selectedItemIds.length === this.allItems.length) {
      this.selectedItemIds = [this.itemId]; // keep primary selected
    } else {
      this.selectedItemIds = this.allItems.map(i => i.id);
      // load registros for any new items
      this.cargarRegistros();
      return;
    }
    this.refreshMultiItemView();
  }

  // Called from UI when user switches monthsToShow
  changeMonths(n: number) {
    if (this.monthsToShow === n) return;
    this.monthsToShow = n;

    // Keep context: if multiple items are selected, redraw multi-item view
    if (this.selectedItemIds && this.selectedItemIds.length > 1) {
      this.refreshMultiItemView();
      return;
    }

    // Else single-item path
    // Ensure datesCache is filled from per-item cache if needed
    if ((!this.datesCache || this.datesCache.length === 0) && this.datesCacheByItem[this.itemId]) {
      this.datesCache = this.datesCacheByItem[this.itemId];
    }
    const { labels, counts, percentChange, trend } = this.aggregateByMonth(this.datesCache || [], this.monthsToShow);
    this.lastPercentChangeText = percentChange;
    this.autogeneratedCaption = this.buildAutogeneratedCaption(counts, percentChange);
    const itemColor = this.getColorForItem(this.itemId);
    this.dibujarGraficoMensual(labels, counts, trend, itemColor);
  }

  // ---------- AGGREGATION / TREND HELPERS ----------
  aggregateByMonth(dates: Date[], monthsToShow: number) {
    const end = new Date();
    const start = new Date(end.getFullYear(), end.getMonth() - (monthsToShow - 1), 1);
    const keyOf = (d: Date) => `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, '0')}`;

    const monthKeys: string[] = [];
    const labels: string[] = [];
    const countsMap = new Map<string, number>();
    for (let i = 0; i < monthsToShow; i++) {
      const dd = new Date(start.getFullYear(), start.getMonth() + i, 1);
      const k = keyOf(dd);
      monthKeys.push(k);
      labels.push(new Intl.DateTimeFormat('es-ES', { month: 'short', year: 'numeric' }).format(dd));
      countsMap.set(k, 0);
    }

    for (const d of dates) {
      const k = keyOf(d);
      if (countsMap.has(k)) countsMap.set(k, (countsMap.get(k) || 0) + 1);
    }

    const counts = monthKeys.map(k => countsMap.get(k) || 0);

    // Percent change last month vs previous
    let percentChangeText = 'Sin datos';
    if (counts.length >= 2) {
      const last = counts[counts.length - 1];
      const prev = counts[counts.length - 2] || 0;
      if (prev === 0 && last === 0) percentChangeText = '0%';
      else if (prev === 0 && last > 0) percentChangeText = `▲ ${last} (antes 0)`;
      else {
        const pct = ((last - prev) / prev) * 100;
        percentChangeText = `${pct >= 0 ? '▲' : '▼'} ${Math.abs(pct).toFixed(1)}%`;
      }
    }

    const trend = this.linearRegressionTrend(counts);
    return { labels, counts, percentChange: percentChangeText, trend };
  }

  linearRegressionTrend(values: number[]) {
    const n = values.length;
    if (n === 0) return [];
    const xs = values.map((_, i) => i);
    const xMean = xs.reduce((a, b) => a + b, 0) / n;
    const yMean = values.reduce((a, b) => a + b, 0) / n;
    let num = 0, den = 0;
    for (let i = 0; i < n; i++) {
      num += (xs[i] - xMean) * (values[i] - yMean);
      den += (xs[i] - xMean) * (xs[i] - xMean);
    }
    const slope = den === 0 ? 0 : num / den;
    const intercept = yMean - slope * xMean;
    return xs.map(x => intercept + slope * x);
  }

  private ensureAlpha(hexOrColor: string, alpha: number) {
    if (!hexOrColor) return `rgba(63,81,181,${alpha})`;
    if (hexOrColor.startsWith('rgba') || hexOrColor.startsWith('hsla')) return hexOrColor;
    const hex = hexOrColor.replace('#', '');
    if (hex.length === 3) {
      const r = parseInt(hex[0] + hex[0], 16);
      const g = parseInt(hex[1] + hex[1], 16);
      const b = parseInt(hex[2] + hex[2], 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    if (hex.length === 6) {
      const r = parseInt(hex.substr(0,2), 16);
      const g = parseInt(hex.substr(2,2), 16);
      const b = parseInt(hex.substr(4,2), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    return hexOrColor;
  }

  // Return a concrete color string for a given itemId or the default brand color
  private getColorForItem(itemId?: string): string {
    if (itemId && this.itemsInfo && this.itemsInfo[itemId] && this.itemsInfo[itemId].color) {
      return this.itemsInfo[itemId].color;
    }
    const computed = getComputedStyle(document.documentElement).getPropertyValue('--brand-300') || '';
    const color = computed.trim();
    if (color) return color;
    return '#3f51b5';
  }

  // Modified dibujarGraficoMensual that accepts a baseColor
  dibujarGraficoMensual(labels: string[], counts: number[], trend: number[], baseColor?: string) {
    if (this.chart) this.chart.destroy();
    const color = baseColor || this.getColorForItem(this.itemId);
    const ctx = this.chartCanvas.nativeElement.getContext('2d')!;
    this.chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { type: 'bar', label: 'Registros por mes', data: counts, backgroundColor: color, borderRadius: 6 },
          { type: 'line', label: 'Tendencia', data: trend, borderColor: this.ensureAlpha(color, 0.9), borderWidth: 2, fill: false, tension: 0.2, pointRadius: 0, borderDash: [6,4] }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: true, position: 'top' }, title: { display: true, text: `Progresión de "${this.itemNombre}" — Mensual (últimos ${labels.length} meses)` } },
        scales: { y: { beginAtZero: true, title: { display: true, text: 'Cantidad' } }, x: { title: { display: true, text: 'Mes' } } }
      }
    });
  }

  // Short autogenerated caption
  private buildAutogeneratedCaption(counts: number[], percentChangeText: string) {
    if (!counts || counts.length === 0) return '';
    const last = counts[counts.length - 1] || 0;
    const total = counts.reduce((a,b) => a+b, 0);
    return `Último mes: ${last}. Total últimos ${this.monthsToShow} meses: ${total}.`;
  }

  descargarJPEG() {
    const el = this.exportContainer?.nativeElement || this.chartCanvas.nativeElement;
    html2canvas(el, { scale: 2 }).then(canvas => {
      const link = document.createElement('a');
      const safeName = (this.itemNombre || 'item').replace(/[^a-z0-9_\-]/gi, '_');
      link.download = `estadistica_${safeName}.jpeg`;
      link.href = canvas.toDataURL('image/jpeg', 0.92);
      link.click();
    });
  }

  volver() {
    this.router.navigate([
      `/dashboard/detalle/${this.tipo}/${this.id}/items/${this.itemId}/registros`
    ]);
  }
}