import { Component, OnInit, ElementRef, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { Firestore, collection, collectionData, doc, getDoc } from '@angular/fire/firestore';
import { Chart, registerables } from 'chart.js';
import html2canvas from 'html2canvas';
import { map } from 'rxjs/operators';
import { MatDialogModule, MatDialog } from '@angular/material/dialog';
import { NoRegistrosDialog } from './no-registro-dialog/no-registro-dialog';
import { take } from 'rxjs/operators';
import { MatIconModule } from '@angular/material/icon';
import { Filesystem, Directory } from '@capacitor/filesystem';
import { Share } from '@capacitor/share';
import { Capacitor } from '@capacitor/core'; 

Chart.register(...registerables);

@Component({
  selector: 'app-registro-stats',
  standalone: true,
  imports: [CommonModule, MatDialogModule, MatIconModule],
  templateUrl: './registro-stats.html',
  styleUrls: ['./registro-stats.scss']
})
export class RegistroStats implements OnInit {
  @ViewChild('chartCanvas') chartCanvas!: ElementRef<HTMLCanvasElement>;
  @ViewChild('exportContainer') exportContainer!: ElementRef<HTMLDivElement>;

  tipo!: 'personas' | 'grupos';
  id!: string;
  itemId!: string;
  itemNombre: string = '';
  chart: any;
  allItems: any[] = [];   // todos los items del usuario/grupo
  selectedItemIds: string[] = []; // ids seleccionados (incluye item principal)
  datesCacheByItem: Record<string, Date[]> = {}; // cache por item
  itemsInfo: Record<string, any> = {}; // color, descripcion, etc.

  // Configuración: cuántos meses mostrar en la comparación mensual
  monthsToShow = 6; // default
  monthsOptions = [3, 6, 12];

  // UI helpers
  lastPercentChangeText: string = '';
  autogeneratedCaption: string = '';

  //  Cache de fechas para el ítem principal (para path single-item)
  private datesCache: Date[] = [];

  constructor(
    private route: ActivatedRoute,
    private firestore: Firestore,
    private router: Router,
    private dialog: MatDialog
  ) {}

  async ngOnInit() {
    this.tipo = this.route.snapshot.paramMap.get('tipo') as 'personas' | 'grupos';
    this.id = this.route.snapshot.paramMap.get('id')!;
    this.itemId = this.route.snapshot.paramMap.get('itemId')!;

    // 1. Obtener nombre del ítem
    const itemRef = doc(this.firestore, `${this.tipo}/${this.id}/items/${this.itemId}`);
    const itemSnap = await getDoc(itemRef);
    if (itemSnap.exists()) {
      this.itemNombre = itemSnap.data()['descripcion'] || '(Sin nombre)';
    } else {
      this.itemNombre = '(Ítem no encontrado)';
    }

    // 1.b Cargar todos los items del usuario/grupo para selección múltiple
    const itemsRef = collection(this.firestore, `${this.tipo}/${this.id}/items`);
    collectionData(itemsRef, { idField: 'id' }).subscribe((items: any[]) => {
      this.allItems = items.filter(i => i.fecha); // aseguramos consistencia

      // Guardar info de cada item
      for (const it of this.allItems) {
        this.itemsInfo[it.id] = {
          descripcion: it.descripcion,
          color: it.color || '#3f51b5'  // color por defecto
        };
      }

      // Seleccionar por defecto solo el item principal
      this.selectedItemIds = [this.itemId];

      // Una vez cargados, podemos cargar registros
      this.cargarRegistros();
    });
  }

  cargarRegistros() {
    // cargar registros para los items actualmente seleccionados
    for (const itemId of this.selectedItemIds) {
      const registrosRef = collection(
        this.firestore,
        `${this.tipo}/${this.id}/items/${itemId}/registros`
      );

      collectionData(registrosRef, { idField: 'id' })
        .pipe(
          map((registros: any[]) =>
            registros
              .filter(r => r.fecha)
              .sort(
                (a, b) =>
                  new Date(a.fecha.seconds ? a.fecha.seconds * 1000 : a.fecha).getTime() -
                  new Date(b.fecha.seconds ? b.fecha.seconds * 1000 : b.fecha).getTime()
              )
          )
        )
        .subscribe((registrosOrdenados) => {

          // Convertir a Date
          const fechas = registrosOrdenados.map(r =>
            new Date(r.fecha.seconds ? r.fecha.seconds * 1000 : r.fecha)
          );

          // Guardar cache por ítem
          this.datesCacheByItem[itemId] = fechas;

          // Mantener cache principal si es el ítem actual
          if (itemId === this.itemId) {
            this.datesCache = fechas;
          }

          // Redibujar
          this.refreshMultiItemView();
        });
    }
  }

  refreshMultiItemView() {
    // If only one item is selected, draw the single-item chart so caption/percent are consistent
    if (this.selectedItemIds.length === 1) {
      const onlyId = this.selectedItemIds[0];
      const fechas = this.datesCacheByItem[onlyId] || [];
      this.datesCache = fechas;
      const { labels, counts, percentChange, trend } = this.aggregateByMonth(fechas, this.monthsToShow);
      this.lastPercentChangeText = percentChange;
      this.autogeneratedCaption = this.buildAutogeneratedCaption(counts, percentChange);
      const itemColor = this.getColorForItem(onlyId);
      this.dibujarGraficoMensual(labels, counts, trend, itemColor);
      return;
    }

    // Multi-item: build datasets
    const datasets: any[] = [];
    let labels: string[] = [];

    for (const itemId of this.selectedItemIds) {
      const fechas = this.datesCacheByItem[itemId] || [];
      const { labels: lbls, counts, trend } = this.aggregateByMonth(fechas, this.monthsToShow);
      labels = lbls; // mismas labels para todos

      const info = this.itemsInfo[itemId] || { descripcion: itemId, color: '#888' };

      datasets.push({
        type: 'bar',
        label: info.descripcion,
        data: counts,
        backgroundColor: info.color,
        borderRadius: 6
      });

      datasets.push({
        type: 'line',
        label: `${info.descripcion} — Tendencia`,
        data: trend,
        borderColor: this.ensureAlpha(info.color, 0.6),
        borderWidth: 2,
        fill: false,
        tension: 0.3,
        pointRadius: 0,
        borderDash: [5, 4]
      });
    }

    this.dibujarGraficoMulti(labels, datasets);
  }

  dibujarGraficoMulti(labels: string[], datasets: any[]) {
    if (this.chart) this.chart.destroy();

    const ctx = this.chartCanvas.nativeElement.getContext('2d')!;
    this.chart = new Chart(ctx, {
      type: 'bar',
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, position: 'top' },
          title: { display: true, text: `Progresión combinada — Últimos ${labels.length} meses` }
        },
        scales: {
          y: { beginAtZero: true, title: { display: true, text: 'Cantidad' } },
          x: { title: { display: true, text: 'Mes' } }
        }
      }
    });
  }

  toggleItem(item: any) {
  // Si deseleccionando un ítem
  if (this.selectedItemIds.includes(item.id)) {
    this.selectedItemIds = this.selectedItemIds.filter(id => id !== item.id);
    this.refreshMultiItemView();
    return;
  }

  // Si agregando un ítem -> verificar si tiene registros antes de aceptar
  const registrosRef = collection(
    this.firestore,
    `${this.tipo}/${this.id}/items/${item.id}/registros`
  );

  collectionData(registrosRef, { idField: 'id' })
    .pipe(
      map((registros: any[]) => registros.filter(r => r.fecha)),
      take(1) // solo necesitamos la primera emisión
    )
    .subscribe({
      next: (registros) => {
        if (registros.length === 0) {
          this.dialog.open(NoRegistrosDialog, { width: '400px' });
          return;
        }

        // permitir selección
        this.selectedItemIds.push(item.id);

        const fechas = registros.map(r =>
          new Date(r.fecha.seconds ? r.fecha.seconds * 1000 : r.fecha)
        );
        this.datesCacheByItem[item.id] = fechas;
        this.refreshMultiItemView();
      },
      error: (err) => {
        if ((err as any).code === 'permission-denied') {
          // Probablemente por logout: lo ignoramos para no ensuciar la consola
          console.debug('Firestore permission error ignorado (posible logout)', err);
          return;
        }
        console.error('Error en toggleItem:', err);
      }
    });
  }

  // Seleccionar o deseleccionar todos los ítems
  toggleSelectAll() {
    if (this.selectedItemIds.length === this.allItems.length) {
      this.selectedItemIds = [this.itemId]; // mantener el ítem principal seleccionado
    } else {
      this.selectedItemIds = this.allItems.map(i => i.id);
      // cargar registros para cualquier ítem nuevo
      this.cargarRegistros();
      return;
    }
    this.refreshMultiItemView();
  }

  // Llamado desde la UI cuando el usuario cambia monthsToShow
  changeMonths(n: number) {
    if (this.monthsToShow === n) return;
    this.monthsToShow = n;

    // Mantener contexto: si hay múltiples ítems seleccionados, redibujar vista multi-ítem
    if (this.selectedItemIds && this.selectedItemIds.length > 1) {
      this.refreshMultiItemView();
      return;
    }

    // si solo un ítem, redibujar vista single-ítem
    // asegura que use la cache correcta
    if ((!this.datesCache || this.datesCache.length === 0) && this.datesCacheByItem[this.itemId]) {
      this.datesCache = this.datesCacheByItem[this.itemId];
    }
    const { labels, counts, percentChange, trend } = this.aggregateByMonth(this.datesCache || [], this.monthsToShow);
    this.lastPercentChangeText = percentChange;
    this.autogeneratedCaption = this.buildAutogeneratedCaption(counts, percentChange);
    const itemColor = this.getColorForItem(this.itemId);
    this.dibujarGraficoMensual(labels, counts, trend, itemColor);
  }

      // agrega N meses a un conjunto de fechas y devuelve labels, counts, percentChange y trend
    aggregateByMonth(dates: Date[], monthsToShow: number) {
    const end = new Date();
    const start = new Date(end.getFullYear(), end.getMonth() - (monthsToShow - 1), 1);
    const keyOf = (d: Date) => `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, '0')}`;

    const monthKeys: string[] = [];
    const labels: string[] = [];
    const countsMap = new Map<string, number>();
    for (let i = 0; i < monthsToShow; i++) {
      const dd = new Date(start.getFullYear(), start.getMonth() + i, 1);
      const k = keyOf(dd);
      monthKeys.push(k);
      labels.push(new Intl.DateTimeFormat('es-ES', { month: 'short', year: 'numeric' }).format(dd));
      countsMap.set(k, 0);
    }

    for (const d of dates) {
      const k = keyOf(d);
      if (countsMap.has(k)) countsMap.set(k, (countsMap.get(k) || 0) + 1);
    }

    const counts = monthKeys.map(k => countsMap.get(k) || 0);

    // Cambio porcentual último mes vs anterior
    let percentChangeText = 'Sin datos';
    if (counts.length >= 2) {
      const last = counts[counts.length - 1];
      const prev = counts[counts.length - 2] || 0;
      if (prev === 0 && last === 0) percentChangeText = '0%';
      else if (prev === 0 && last > 0) percentChangeText = `▲ ${last} (antes 0)`;
      else {
        const pct = ((last - prev) / prev) * 100;
        percentChangeText = `${pct >= 0 ? '▲' : '▼'} ${Math.abs(pct).toFixed(1)}%`;
      }
    }

    const trend = this.linearRegressionTrend(counts);
    return { labels, counts, percentChange: percentChangeText, trend };
  }
  // Regresión lineal simple para obtener la línea de tendencia
  linearRegressionTrend(values: number[]) {
    const n = values.length;
    if (n === 0) return [];
    const xs = values.map((_, i) => i);
    const xMean = xs.reduce((a, b) => a + b, 0) / n;
    const yMean = values.reduce((a, b) => a + b, 0) / n;
    let num = 0, den = 0;
    for (let i = 0; i < n; i++) {
      num += (xs[i] - xMean) * (values[i] - yMean);
      den += (xs[i] - xMean) * (xs[i] - xMean);
    }
    const slope = den === 0 ? 0 : num / den;
    const intercept = yMean - slope * xMean;
    return xs.map(x => intercept + slope * x);
  }

  // Asegura que un color hex o rgb tenga el canal alpha adecuado
  private ensureAlpha(hexOrColor: string, alpha: number) {
    if (!hexOrColor) return `rgba(63,81,181,${alpha})`;
    if (hexOrColor.startsWith('rgba') || hexOrColor.startsWith('hsla')) return hexOrColor;
    const hex = hexOrColor.replace('#', '');
    if (hex.length === 3) {
      const r = parseInt(hex[0] + hex[0], 16);
      const g = parseInt(hex[1] + hex[1], 16);
      const b = parseInt(hex[2] + hex[2], 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    if (hex.length === 6) {
      const r = parseInt(hex.substr(0,2), 16);
      const g = parseInt(hex.substr(2,2), 16);
      const b = parseInt(hex.substr(4,2), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    return hexOrColor;
  }

  // Devuelve un color concreto para un itemId dado o el color de marca por defecto
  private getColorForItem(itemId?: string): string {
    if (itemId && this.itemsInfo && this.itemsInfo[itemId] && this.itemsInfo[itemId].color) {
      return this.itemsInfo[itemId].color;
    }
    const computed = getComputedStyle(document.documentElement).getPropertyValue('--brand-300') || '';
    const color = computed.trim();
    if (color) return color;
    return '#3f51b5';
  }

  // Modificado dibujarGraficoMensual que acepta un baseColor
  dibujarGraficoMensual(labels: string[], counts: number[], trend: number[], baseColor?: string) {
    if (this.chart) this.chart.destroy();
    const color = baseColor || this.getColorForItem(this.itemId);
    const ctx = this.chartCanvas.nativeElement.getContext('2d')!;
    this.chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { type: 'bar', label: 'Registros por mes', data: counts, backgroundColor: color, borderRadius: 6 },
          { type: 'line', label: 'Tendencia', data: trend, borderColor: this.ensureAlpha(color, 0.9), borderWidth: 2, fill: false, tension: 0.2, pointRadius: 0, borderDash: [6,4] }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: true, position: 'top' }, title: { display: true, text: `Progresión de "${this.itemNombre}" — Mensual (últimos ${labels.length} meses)` } },
        scales: { y: { beginAtZero: true, title: { display: true, text: 'Cantidad' } }, x: { title: { display: true, text: 'Mes' } } }
      }
    });
  }

  // Leyenda autogenerada
  private buildAutogeneratedCaption(counts: number[], percentChangeText: string) {
    if (!counts || counts.length === 0) return '';
    const last = counts[counts.length - 1] || 0;
    const total = counts.reduce((a,b) => a+b, 0);
    return `Último mes: ${last}. Total últimos ${this.monthsToShow} meses: ${total}.`;
  }

  
  // Descargar gráfico como JPEG compatible para web y app android
async descargarJPEG() {
  try {
    const el = this.exportContainer?.nativeElement || this.chartCanvas?.nativeElement;
    if (!el) {
      console.error('Elemento no encontrado!');
      return;
    }

    // Renderizar canvas con html2canvas
    const canvas: HTMLCanvasElement = await html2canvas(el, { scale: 2 });
    
    // Convertir canvas -> Blob (jpeg)
    const blob: Blob | null = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.92));
    if (!blob) {
      console.error('canvas.toBlob devuelve null');
      return;
    }

    // Web vs Nativo 
    if (Capacitor.isNativePlatform()) {
      // 3) Blob -> base64 (quitar prefijo) - SOLO PARA ANDROID/iOS
      const base64 = await new Promise<string>((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve((reader.result as string).split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

      // Componer nombre de archivo y ruta de escritura
      const safeName = (this.itemNombre || 'item').replace(/[^a-z0-9_\-]/gi, '_');
      const fileName = `estadistica_${safeName}.jpeg`;
      const folder = 'Pictures/Progression'; // subcarpeta específica de la app dentro de Pictures

      //Crear el directorio 
      try {
        await Filesystem.mkdir({
          path: folder,
          directory: Directory.External,
          recursive: true // crea carpetas intermedias si no existen
        });
        console.log('Directorio creado o ya existe:', folder);
      } catch (mkdirErr: any) {
        // Si falla, registrar y continuar — a veces la ruta ya existe o la plataforma se comporta de manera diferente
        console.warn('Error al crear directorio (puede estar bien):', mkdirErr);
      }

      // Escribir el archivo
      const writeResult = await Filesystem.writeFile({
        path: `${folder}/${fileName}`,
        data: base64,
        directory: Directory.External,
      });

      console.log('Resultado:', writeResult); 

      // Obtener URI para compartir/abrir
      const uriResult = await Filesystem.getUri({
        directory: Directory.External,
        path: `${folder}/${fileName}`,
      });

      const nativeUri = uriResult.uri;
      console.log('Archivo guardado URI:', nativeUri);

      //Abrir diálogo nativo para compartir
      await Share.share({
        title: 'Estadística',
        text: 'Aquí tienes la estadística como JPEG',
        url: nativeUri
      });

      console.log('Diálogo abierto.');
    } else {
      //WEB: Descarga directa (NO llega aquí en Android)
      console.log(' Web platform - descarga directa');
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const safeName = (this.itemNombre || 'item').replace(/[^a-z0-9_\-]/gi, '_');
      a.href = url;
      a.download = `estadistica_${safeName}.jpeg`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      console.log('Imagen descargada en web');
    }

  } catch (err) {
    console.error('Error en descargarJPEG:', err);
  }
}


  volver() {
    this.router.navigate([
      `/dashboard/detalle/${this.tipo}/${this.id}/items/${this.itemId}/registros`
    ]);
  }
}
